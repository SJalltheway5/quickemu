#!/usr/bin/env bash
export LC_ALL=C
[ -z ${XDG_DATA_HOME} ] && XDG_DATA_HOME=${HOME}/.local/share

function disk_delete() {
  if [ -e "${disk_img}" ]; then
    rm "${disk_img}"
    echo "SUCCESS! Deleted ${disk_img}"
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_apply() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    ${QEMU_IMG} snapshot -q -a "${TAG}" "${disk_img}"
    if [ $? -eq 0 ]; then
      echo "SUCCESS! Applied snapshot ${TAG} to ${disk_img}"
    else
      echo "ERROR! Failed to apply snapshot ${TAG} to ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_create() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    ${QEMU_IMG} snapshot -q -c "${TAG}" "${disk_img}"
    if [ $? -eq 0 ]; then
      echo "SUCCESS! Created snapshot ${TAG} of ${disk_img}"
    else
      echo "ERROR! Failed to create snapshot ${TAG} of ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_delete() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    ${QEMU_IMG} snapshot -q -d "${TAG}" "${disk_img}"
    if [ $? -eq 0 ]; then
      echo "SUCCESS! Deleted snapshot ${TAG} of ${disk_img}"
    else
      echo "ERROR! Failed to delete snapshot ${TAG} of ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_info() {
  if [ -e "${disk_img}" ]; then
    ${QEMU_IMG} info "${disk_img}"
  fi
}

function get_port() {
    local PORT_START=22220
    local PORT_RANGE=9
    while true; do
        local CANDIDATE=$[${PORT_START} + (${RANDOM} % ${PORT_RANGE})]
        (echo "" >/dev/tcp/127.0.0.1/${CANDIDATE}) >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo "${CANDIDATE}"
            break
        fi
    done
}

# Automatically create .desktop launcher after VM's first successful boot (WIP)
# Also called from mk_conf()
function mk_desktop_file() {
  # Uses "Pretty" name from .conf, otherwise falls back to "Ugly" name
  local VMNAME_U="$(echo ${VM} | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev)"
  VMNAME_U=${VMNAME_U// /}
  local VMNAME_P="${VMNAME_P}"
  [ -z "${VMNAME_P}" ] && VMNAME_P="${vmname}"
  [ -z "${VMNAME_P}" ] && VMNAME_P="${VMNAME_U}"

  local DESKTOP_FILE="${XDG_DATA_HOME}/applications/${VMNAME_U}".desktop

  if [ ! -f "${DESKTOP_FILE}" ] || [ "${FORCE_DESKTOP_FILE}" = "1" ]; then
    # Get absolute paths of LAUNCHER and VM for Exec=
    local LAUNCHER_ABSPTH="$(cd "${0%/*}" && pwd)/${LAUNCHER}"
    local VM_ABSPTH="$(cd "$(dirname "${VM}")" && pwd)/$(basename "${VM}")"
    echo "[Desktop Entry]" > "${DESKTOP_FILE}"
    echo "Version=1.0" >> "${DESKTOP_FILE}"
    echo "Type=Application" >> "${DESKTOP_FILE}"
    echo "Name=${VMNAME_P}" >> "${DESKTOP_FILE}"
    echo "Comment=Quickemu VM" >> "${DESKTOP_FILE}"
    echo "Exec='${LAUNCHER_ABSPTH}' --vm '${VM_ABSPTH}'" >> "${DESKTOP_FILE}"
    # Category for this?
    echo "Categories=;" >> "${DESKTOP_FILE}"
    # Need to sort out setting a proper icon
    echo "Icon=application-default-icon" >> "${DESKTOP_FILE}"
    echo "Terminal=false" >> "${DESKTOP_FILE}"
    echo "StartupNotify=false" >> "${DESKTOP_FILE}"
  fi
}

# Interactively create new .conf if VM doesn't already exist (WIP)
function mk_conf() {
  echo "  Ctrl-C to abort"
  echo

  # VM name
  local VMNAME_P
  echo -n "VM name: "
  read VMNAME_P

  # Guest OS type
  local GUEST_OS
  local GUEST_OS_TAB="/tmp/quickemu/GUEST_OS"
  # Really hacky tab completion
  [ -d ${GUEST_OS_TAB} ] || mkdir -p ${GUEST_OS_TAB}
  cd ${GUEST_OS_TAB}
  touch linux windows
  while [ "${GUEST_OS}" != "linux" ] && [ "${GUEST_OS}" != "windows" ]; do
    echo -n "Guest OS type [linux|windows]: "
    read -e GUEST_OS
    echo "linuxwindows" | grep "${GUEST_OS}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "Guest OS not supported."
    elif [ -z "${GUEST_OS}" ]; then
      GUEST_OS="linux"
      echo "Defaulting to ${GUEST_OS}"
    fi
  done
  cd - >/dev/null
  local WIN_VIRTIO_ISO
  if [ "${GUEST_OS}" == "windows" ]; then
    echo "Running Windows as a guest OS requires VirtIO drivers."
    echo "A .iso file can be found here:"
    echo
    echo "https://docs.fedoraproject.org/en-US/quick-docs/creating-windows-virtual-machines-using-virtio-drivers/index.html#virtio-win-direct-downloads"
    echo
    while [ -z "${WIN_VIRTIO_ISO}" ]; do
      echo -n "VirtIO drivers ISO: "
      read -e WIN_VIRTIO_ISO
      WIN_VIRTIO_ISO="${WIN_VIRTIO_ISO//'~'/$HOME}"
      # Check for and remove '' to allow drag-and-drop into some terminal emulators
      if [ "$(echo "${WIN_VIRTIO_ISO}" | cut -c -1)" == "'" ] && \
        [ "$(echo "${WIN_VIRTIO_ISO}" | rev | cut -c -1)" == "'" ]; then
        WIN_VIRTIO_ISO="$(echo "${WIN_VIRTIO_ISO}" | cut -c 2-)"
        WIN_VIRTIO_ISO="$(echo "${WIN_VIRTIO_ISO}" | rev | cut -c 2- | rev)"
      fi
      if [ -z "${WIN_VIRTIO_ISO}" ]; then
        echo
      elif [ ! -f "${WIN_VIRTIO_ISO}" ]; then
        echo "ERROR! File \"${WIN_VIRTIO_ISO}\" does not exist."
        WIN_VIRTIO_ISO=""
      fi
    done
    WIN_VIRTIO_ISO="$(cd "$(dirname "${WIN_VIRTIO_ISO}")" && pwd)/$(basename "${WIN_VIRTIO_ISO}")"
  fi

  # Boot type
  local BOOT_TYPE
  local BOOT_TYPE_TAB="/tmp/quickemu/BOOT_TYPE"
  # Really hacky tab completion
  [ -d ${BOOT_TYPE_TAB} ] || mkdir -p ${BOOT_TYPE_TAB}
  cd ${BOOT_TYPE_TAB}
  touch legacy efi
  while [ "${BOOT_TYPE}" != "legacy" ] && [ "${BOOT_TYPE}" != "efi" ]; do
    echo -n "Boot type [legacy|efi]: "
    read -e BOOT_TYPE
    echo "legacyuefi" | grep "${BOOT_TYPE}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "Invalid boot type."
    elif [ -z "${BOOT_TYPE}" ]; then
      BOOT_TYPE="legacy"
      echo "Defaulting to ${BOOT_TYPE}"
    fi
  done
  cd - >/dev/null
  # Hide all the evidence and don't tell anyone.
  rm -rf /tmp/quickemu

  # Virtual disk image
  # Still pondering the cleanest way to handle disk image/ISO...
  # I guess this is okay, till it isn't.
  local DISK_IMG
  local DISK_SIZE
  DISK_IMG=${VM// /}
  DISK_IMG=${DISK_IMG//.conf/}.qcow2
  if [ -f "${DISK_IMG}" ]; then
    echo "  Existing disk image found."
    local DISK_CURR_SIZE=$(stat -c%s "${DISK_IMG}")
    [ ${DISK_CURR_SIZE} -le ${DISK_MIN_SIZE} ] || local DISK_IMG_EXISTS=1
  elif [ -z "${DISK_IMG}" ]; then
    true
  else
    echo -n "Virtual hard disk size [default 64G]: "
    read DISK_SIZE
    if [ -z ${DISK_SIZE} ]; then
      # Why is this printing on a new line?
      #echo "Defaulting to 64G"
      DISK_SIZE="64G"
    fi
  fi
  DISK_IMG="$(cd "$(dirname "${DISK_IMG}")" && pwd)/$(basename "${DISK_IMG}")"

  # ISO file
  local ISO_FILE
  if [ "${DISK_IMG_EXISTS}" != "1" ]; then
    while [ -z "${ISO_FILE}" ]; do
      echo -n "ISO file to boot: "
      read -e ISO_FILE
      ISO_FILE="${ISO_FILE//'~'/$HOME}"
      # Check for and remove '' to allow drag-and-drop into some terminal emulators
      if [ "$(echo "${ISO_FILE}" | cut -c -1)" == "'" ] && \
        [ "$(echo "${ISO_FILE}" | rev | cut -c -1)" == "'" ]; then
        ISO_FILE="$(echo "${ISO_FILE}" | cut -c 2-)"
        ISO_FILE="$(echo "${ISO_FILE}" | rev | cut -c 2- | rev)"
      fi
      if [ -z "${ISO_FILE}" ]; then
        echo
      elif [ ! -f "${ISO_FILE}" ]; then
        echo "ERROR! File \"${ISO_FILE}\" does not exist."
        ISO_FILE=""
      fi
    done
  fi
  [ -n "${ISO_FILE}" ] && \
    ISO_FILE="$(cd "$(dirname "${ISO_FILE}")" && pwd)/$(basename "${ISO_FILE}")"
  # </pondering>

  # Generate the .conf file, make a .desktop launcher, and exit
  #local CONF_FILE="${VM}"
  echo
  echo "More settings can be configured in ${VM}."

  echo "# Configuration for \"${VMNAME_P}\" Quickemu VM" > ${VM}
  echo "vmname=\"${VMNAME_P}\"" >> ${VM}
  echo "guest_os=\"${GUEST_OS}\"" >> ${VM}
  echo "boot=\"${BOOT_TYPE}\"" >> ${VM}
  echo "iso=\"${ISO_FILE}\"" >> ${VM}
  echo "disk_img=\"${DISK_IMG}\"" >> ${VM}
  [ -z ${WIN_VIRTIO_ISO} ] || echo "driver_iso=\"${WIN_VIRTIO_ISO}\"" >> ${VM} 
  echo "disk=\"${DISK_SIZE}\"" >> ${VM}
  for i in ram cores xres yres hostname; do
    echo "$i=\"\"" >> ${VM}
  done
  
  echo "Launch the new VM with \"${VMNAME_P}\" from the menu or run:"
  echo "  ${LAUNCHER} --vm \"${VM}\""

  export VMNAME_P
  FORCE_DESKTOP_FILE="1"
  mk_desktop_file
  exit 0
}

enable_usb_passthrough() {
  local DEVICE=""
  local USB_BUS=""
  local USB_DEV=""
  local USB_NAME=""
  local VENDOR_ID=""
  local PRODUCT_ID=""
  local TEMP_SCRIPT=$(mktemp)
  local EXEC_SCRIPT=0

  # Have any USB devices been requested for pass-through?
  if (( ${#usb_devices[@]} )); then
    echo " - USB:      Device pass-through requested:"
    echo "#!/usr/bin/env bash" > "${TEMP_SCRIPT}"
    for DEVICE in "${usb_devices[@]}"; do
      VENDOR_ID=$(echo ${DEVICE} | cut -d':' -f1)
      PRODUCT_ID=$(echo ${DEVICE} | cut -d':' -f2)
      USB_BUS=$(lsusb -d ${VENDOR_ID}:${PRODUCT_ID} | cut -d' ' -f2)
      USB_DEV=$(lsusb -d ${VENDOR_ID}:${PRODUCT_ID} | cut -d' ' -f4 | cut -d':' -f1)
      USB_NAME=$(lsusb -d ${VENDOR_ID}:${PRODUCT_ID} | cut -d' ' -f7-)
      echo "              - ${USB_NAME}"
      USB_PASSTHROUGH="${USB_PASSTHROUGH} -usb -device usb-host,vendorid=0x${VENDOR_ID},productid=0x${PRODUCT_ID}"

      if [ ! -w /dev/bus/usb/${USB_BUS}/${USB_DEV} ]; then
        local EXEC_SCRIPT=1
        echo "chown root:${USER} /dev/bus/usb/${USB_BUS}/${USB_DEV}" >> "${TEMP_SCRIPT}"
      fi
    done

    if [ ${EXEC_SCRIPT} -eq 1 ]; then
      chmod +x "${TEMP_SCRIPT}"
      echo "             Requested USB device(s) are NOT accessible."
      echo "             ${TEMP_SCRIPT} will be executed to enable access:"
      echo
      cat ${TEMP_SCRIPT}
      echo
      sudo "${TEMP_SCRIPT}"
      if [ $? -ne 0 ]; then
        echo "            WARNING! Enabling USB device access failed."
      fi
    else
      echo "             Requested USB device(s) are accessible."
    fi
    rm -f "${TEMP_SCRIPT}"
  fi
}

function vm_boot() {
  local VMNAME=$(basename "${VM}" .conf)
  local VMDIR=$(dirname "${disk_img}")
  local CPU="-cpu host,kvm=on"
  local GUEST_TWEAKS=""
  local DISPLAY_DEVICE=""
  local VIDEO=""
  local GL="on"
  local VIRGL="on"
  local OUTPUT="sdl"
  local OUTPUT_EXTRA=""
  local QEMU_VER=$(${QEMU} -version | head -n1 | cut -d' ' -f4 | cut -d'(' -f1)
  echo "Starting ${VM}"
  echo " - QEMU:     ${QEMU} v${QEMU_VER}"

  # Force to lowercase.
  boot=$(echo ${boot,,})
  if [ "${boot}" == "efi" ] || [ "${boot}" == "uefi" ]; then
    if [ -e "${VIRGIL_PATH}/usr/share/qemu/edk2-x86_64-code.fd" ] ; then
      local EFI_CODE="${VIRGIL_PATH}/usr/share/qemu/edk2-x86_64-code.fd"
      local EFI_VARS="${VMDIR}/${VMNAME}-vars.fd"
      if [ ! -e "${EFI_VARS}" ]; then
        cp "${VIRGIL_PATH}/usr/share/qemu/edk2-i386-vars.fd" "${EFI_VARS}"
      fi
      echo " - BOOT:     EFI"
    else
      echo " - BOOT:     Legacy BIOS"
      echo " -           EFI Booting requested but no EFI firmware found."
    fi
  else
    echo " - BOOT:     Legacy BIOS"
  fi

  # Force to lowercase.
  guest_os=$(echo ${guest_os,,})
  # Make any OS specific adjustments
  case ${guest_os} in
    linux)
      DISPLAY_DEVICE="virtio-vga"
      ;;
    windows)
      CPU="${CPU},hv_time"
      GUEST_TWEAKS="-no-hpet"
      DISPLAY_DEVICE="qxl-vga"
      ;;
    *)
      echo "ERROR! Unrecognised guest OS: ${guest_os}"
      exit
      ;;
  esac
  echo " - Guest:    ${guest_os^} optimised"

  echo " - Disk:     ${disk_img} (${disk})"
  if [ ! -f "${disk_img}" ]; then
      # If there is no disk image, create a new image.
      mkdir -p "${VMDIR}" 2>/dev/null
      ${QEMU_IMG} create -q -f qcow2 "${disk_img}" "${disk}"
      if [ $? -ne 0 ]; then
        echo "ERROR! Failed to create ${disk_img}"
        exit 1
      fi
      if [ -z "${iso}" ]; then
        echo "ERROR! You haven't specified a .iso image to boot from."
        exit 1
      fi
      echo "             Just created, booting from ${iso}"
    if [ $? -ne 0 ]; then
      echo "ERROR! Failed to create ${disk_img} of ${disk}. Stopping here."
      exit 1
    fi
  elif [ -e "${disk_img}" ]; then
    # Check there isn't already a process attached to the disk image.
    QEMU_LOCK_TEST=$(${QEMU_IMG} info "${disk_img}" 2>/dev/null)
    if [ $? -ne 0 ]; then
      echo "             Failed to get "write" lock. Is another process using the disk?"
      exit 1
    else
      DISK_CURR_SIZE=$(stat -c%s "${disk_img}")
      if [ ${DISK_CURR_SIZE} -le ${DISK_MIN_SIZE} ]; then
        echo "             Looks unused, booting from ${iso}"
        if [ -z "${iso}" ]; then
          echo "ERROR! You haven't specified a .iso image to boot from."
          exit 1
        fi
      else
        # If there is a disk image, that appears to have an install
        # then do not boot from the iso
        iso=""
      fi
    fi
  fi

  # Has the status quo been requested?
  if [ "${STATUS_QUO}" == "-snapshot" ] &&  [ -z "${iso}" ]; then
    echo "             Existing disk state will be preserved, no writes will be committed."
  fi

  if [ -n "${iso}" ] && [ -e "${iso}" ]; then
    echo " - Boot:     ${iso}"
  fi

  if [ -n "${driver_iso}" ] && [ -e "${driver_iso}" ]; then
    echo " - Drivers:  ${driver_iso}"
  fi

  local CORES_VM=${cores}
  if [ -z ${CORES_VM} ]; then
    local CORES_VM="1"
    local CORES_HOST=$(nproc --all)
    if [ ${CORES_HOST} -ge 8 ]; then
      CORES_VM="4"
    elif [ ${CORES_HOST} -ge 4 ]; then
      CORES_VM="2"
    fi
  fi
  echo " - CPU:      ${CORES_VM} Core(s)"

  local RAM_VM=${ram}
  if [ -z ${RAM_VM} ]; then
    local RAM_VM="2G"
    local RAM_HOST=$(free --mega -h | grep Mem | cut -d':' -f2 | cut -d'G' -f1 | sed 's/ //g')
    #Round up - https://github.com/wimpysworld/quickemu/issues/11
    RAM_HOST=$(printf '%.*f\n' 0 ${RAM_HOST})
    if [ ${RAM_HOST} -ge 64 ]; then
      RAM_VM="4G"
    elif [ ${RAM_HOST} -ge 16 ]; then
      RAM_VM="3G"
    fi
  fi
  echo " - RAM:      ${RAM_VM}"

  local X_RES=${xres}
  local Y_RES=${yres}
  if [ -z "${X_RES}" ] || [ -z "${Y_RES}" ]; then
    local X_RES=1152
    local Y_RES=648
    if [ "${XDG_SESSION_TYPE}" == "x11" ]; then
      local LOWEST_WIDTH=$(xrandr --listmonitors | grep -v Monitors | cut -d' ' -f4 | cut -d'/' -f1 | sort | head -n1)
      if [ ${LOWEST_WIDTH} -ge 3840 ]; then
        X_RES=3200
        Y_RES=1800
      elif [ ${LOWEST_WIDTH} -ge 2560 ]; then
        X_RES=2048
        Y_RES=1152
      elif [ ${LOWEST_WIDTH} -ge 1920 ]; then
        X_RES=1664
        Y_RES=936
      elif [ ${LOWEST_WIDTH} -ge 1280 ]; then
        X_RES=1152
        Y_RES=648
      fi
    fi
  fi

  # GL is not working with GTK currently
  if [ "${OUTPUT}" == "gtk" ]; then
    GL="es"
    OUTPUT_EXTRA=",grab-on-hover=on,zoom-to-fit=on"
  else
    echo " - Screen:   ${X_RES}x${Y_RES}"
  fi

  if [ "${DISPLAY_DEVICE}" == "qxl-vga" ]; then
    VIDEO="-device ${DISPLAY_DEVICE},xres=${X_RES},yres=${Y_RES}"
  elif [ "${DISPLAY_DEVICE}" == "virtio-vga" ]; then
    VIDEO="-device ${DISPLAY_DEVICE},virgl=${VIRGL},xres=${X_RES},yres=${Y_RES}"
  else
    VIDEO=" -device VGA,vgamem_mb=32,xres=${X_RES},yres=${Y_RES}"
  fi

  echo " - Video:    ${DISPLAY_DEVICE}"
  echo " - GL:       ${GL^^}"
  echo " - Virgil3D: ${VIRGL^^}"
  echo " - Display:  ${OUTPUT^^}"

  # Set the hostname of the VM
  local VM_HOSTNAME=${hostname}
  [ -z ${VM_HOSTNAME} ] && VM_HOSTNAME="${VMNAME// /}"
  local NET="user,hostname=${VM_HOSTNAME}"

  # If smbd is available, export $HOME to the guest via samba
  if [ -e "${VIRGIL_PATH}/usr/sbin/smbd" ]; then
      NET="${NET},smb=${HOME}"
  fi

  if [[ ${NET} == *"smb"* ]]; then
    echo " - smbd:     ${HOME} will be exported to the guest via smb://10.0.2.4/qemu"
  else
    echo " - smbd:     ${HOME} will not be exported to the guest. 'smbd' not found."
  fi

  # Find a free port to expose ssh to the guest
  local PORT=$(get_port)
  if [ -n "${PORT}" ]; then
    NET="${NET},hostfwd=tcp::${PORT}-:22"
    echo " - ssh:      ${PORT}/tcp is connected. Login via 'ssh user@localhost -p ${PORT}'"
  else
    echo " - ssh:      All ports for exposing ssh have been exhausted."
  fi

  enable_usb_passthrough

  # Set extra EFI options
  if [ "${boot}" == "efi" ] || [ "${boot}" == "uefi" ]; then
    local EFI_OPTS="-drive if=pflash,format=raw,readonly,file=${EFI_CODE}"
    EFI_OPTS="${EFI_OPTS} -drive if=pflash,format=raw,file=${EFI_VARS}"
  fi

  # Boot the iso image
  ${QEMU} \
    -name "${VMNAME}",process="${VMNAME}" \
    -enable-kvm -machine q35 ${GUEST_TWEAKS} \
    ${CPU} -smp ${CORES_VM} \
    -m ${RAM_VM} -device virtio-balloon \
    ${EFI_OPTS} \
    -drive media=cdrom,index=0,file="${iso}" \
    -drive media=cdrom,index=1,file="${driver_iso}" \
    -drive if=none,id=drive0,cache=directsync,aio=native,format=${DISK_TYPE},file="${disk_img}" \
    -device virtio-blk-pci,drive=drive0,scsi=off ${STATUS_QUO} \
    ${VIDEO} -display ${OUTPUT},gl=${GL}${OUTPUT_EXTRA} \
    -device qemu-xhci,id=xhci,p2=8,p3=8 -device usb-kbd,bus=xhci.0 -device usb-tablet,bus=xhci.0 ${USB_PASSTHROUGH} \
    -device virtio-net,netdev=nic -netdev ${NET},id=nic \
    -audiodev pa,id=pa,server=unix:${XDG_RUNTIME_DIR}/pulse/native,out.stream-name=${LAUNCHER}-${VMNAME},in.stream-name=${LAUNCHER}-${VMNAME} \
    -device intel-hda -device hda-duplex,audiodev=pa,mixer=off \
    -rtc base=localtime,clock=host \
    -object rng-random,id=rng0,filename=/dev/urandom \
    -device virtio-rng-pci,rng=rng0 \
    -spice port=5930,disable-ticketing \
    -device virtio-serial-pci \
    -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 \
    -chardev spicevmc,id=spicechannel0,name=vdagent \
    -serial mon:stdio \
    "${@}"
}

function usage() {
  echo
  echo "Usage"
  echo "  ${LAUNCHER} --vm my_vm.conf"
  echo
  echo "You can also pass optional parameters"
  echo "  --delete                : Delete the disk image."
  echo "  --snapshot apply <tag>  : Apply/restore a snapshot."
  echo "  --snapshot create <tag> : Create a snapshot."
  echo "  --snapshot delete <tag> : Delete a snapshot."
  echo "  --snapshot info         : Show disk/snapshot info."
  echo "  --status-quo            : Do not commit any changes to disk/snapshot."
  echo
}

# Lowercase variables are used in the VM config file only
boot="legacy"
guest_os="linux"
iso=""
driver_iso=""
disk_img=""
disk="64G"
usb_devices=()
ram=""
cores=""
xres=""
yres=""
hostname=""
vmname=""

DELETE=0
ENABLE_EFI=0
SNAPSHOT_ACTION=""
SNAPSHOT_TAG=""
STATUS_QUO=""
USB_PASSTHOUGH=""
VM=""

readonly LAUNCHER=$(basename "${0}")
readonly DISK_MIN_SIZE=$((197632 * 8))
readonly QEMU="/snap/bin/qemu-virgil"
readonly QEMU_IMG="/snap/bin/qemu-virgil.qemu-img"
readonly VIRGIL_PATH="/snap/qemu-virgil/current"

if [ -z ${1} ]; then
  usage
  exit 1
fi

while [ $# -gt 0 ]; do
  case "${1}" in
    -delete|--delete)
      DELETE=1
      shift;;
    -snapshot|--snapshot)
      SNAPSHOT_ACTION="${2}"
      if [ -z "${SNAPSHOT_ACTION}" ]; then
        echo "ERROR! No snapshot action provided."
        exit 1
      fi
      shift
      SNAPSHOT_TAG="${2}"
      if [ -z "${SNAPSHOT_TAG}" ] && [ "${SNAPSHOT_ACTION}" != "info" ]; then
        echo "ERROR! No snapshot tag provided."
        exit 1
      fi
      shift
      shift;;
    -status-quo|--status-quo)
      STATUS_QUO="-snapshot"
      shift;;
    -vm|--vm)
      VM="${2}"
      shift
      shift;;
    -h|--h|-help|--help)
      usage
      exit 0;;
    *)
      echo "ERROR! \"${1}\" is not a supported parameter."
      usage
      exit 1;;
  esac
done

# Check we have qemu-virgil available
if [ ! -e "${QEMU}" ] && [ ! -e "${QEMU_IMG}" ]; then
  echo "ERROR! qemu-virgil not found. Please install the qemu-virgil snap:"
  echo
  echo "  snap install qemu-virgil --edge"
  echo "  snap connect qemu-virgil:kvm"
  echo "  snap connect qemu-virgil:removable-media"
  echo
  echo "More information: https://snapcraft.io/qemu-virgil"
  echo
  exit 1
fi

# Prompt to create new .conf file
if [ -n "${VM}" ] && [ -e "${VM}" ]; then
  source "${VM}"
  if [ -z "${disk_img}" ]; then
    echo "ERROR! No disk_img defined."
    exit 1
  fi
else
  echo "Virtual machine configuration not found."
  echo -n "Make one now? [y/N]: "
  read MK_CONF
  [ -z ${MK_CONF} ] && MK_CONF="0"
  echo "yes" | grep -i "${MK_CONF}" >/dev/null && MK_CONF="1"
  if [ ${MK_CONF} = 1 ]; then
    mk_conf
  else
    usage
    exit 1
  fi
fi

if [ ${DELETE} -eq 1 ]; then
  disk_delete
  exit
fi

if [ -n "${SNAPSHOT_ACTION}" ]; then
  case ${SNAPSHOT_ACTION} in
    apply)
      snapshot_apply "${SNAPSHOT_TAG}"
      snapshot_info
      exit;;
    create)
      snapshot_create "${SNAPSHOT_TAG}"
      snapshot_info
      exit;;
    delete)
      snapshot_delete "${SNAPSHOT_TAG}"
      snapshot_info
      exit;;
    info)
      snapshot_info
      exit;;
    *)
      echo "ERROR! \"${SNAPSHOT_ACTION}\" is not a supported snapshot action."
      usage
      exit 1;;
  esac
fi

# Allow all disk image formats supported by qemu.
  DISK_TYPE=$(echo "${disk_img}" | rev | cut -d'.' -f1 | rev)
  DISK_TYPES="bochs,cloop,cow,dmg,nbd,parallels,qcow2,qed,raw,vdi,vhdx,vmdk,vvfat"
  echo ${DISK_TYPES} | grep ${DISK_TYPE} >/dev/null
  if [ $? -gt 0 ]; then
    echo "ERROR! Unsupported disk image type."
    exit 1
  fi

vm_boot && mk_desktop_file
